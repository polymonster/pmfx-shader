/// this is the full schema for pmfx -v2 specification
/// members are listed with their default values, possible values for enums and type ranges are listed in the comments.

/// top level structure, you can omit any sub objects if you do not need them.
/// optional (null) members can be omited entirely
pmfx: {
    /// list of include files
    include: [
        /// include hlsl source code
        "shader_file.hlsl"
        /// include other pmfx files to share pipelines / render states
        "pmfx_file.pmfx"
    ]
    pipelines: {
        /// key-value objects of `pipeline`
        name: {
            // ..
        }
    }
    depth_stencil_states: {
        /// key-value objects of `depth_stencil_state`
        name: {
            // ..
        }
    }
    sampler_states: {
        /// key-value objects of `sampler_state`
        name: {
            // ..
        }
    }
    render_target_blend_states: {
        /// key-value objects of `render_target_blend_state`
        name: {
            // ..
        }
    }
    blend_states: {
        /// key-value objects of `blend_state`
        name: {
            // ..
        }
    }
    textures: {
        name: {
            // ..
        }
    }
    views: {
        name: {
            // ..
        }
    }
    render_graphs: {
        name: {
            // ..
        }
    }
}

/// full pipeline-state object specification
pipeline: {
    /// optional - this will be auto-generated, but you can supply extra information to override
    vertex_layout: {
        // ..
    }
    /// auto-generated (based on shader usage and register bindings)
    desciptor_layout: {
        // ..
    }
    /// specify the name of a shader entry point inside .hlsl files to use as a vertex shader
    /// only makes sense on it's own in combination with ps. cs must be null
    /// type: optional (string or null)
    vs: null
    /// specify the name of a shader entry point inside .hlsl files to use as a pixel shader
    /// only makes sense in combination with vs, vs must be non-null and cs must be null
    /// type: optional (string or null)
    ps: null
    /// specify the name of a shader entry point inside .hlsl files to use as a compute shader
    /// only makes sense in on it's own (vs and ps must be null)
    /// type: optional (string or null)
    cs: null
    // specify a named depth_stencil_state
    // type: optional (string or null) if null or omitted defaults for depth_stencil_state are used.
    depth_stencil_state: null
    // specify a named blend_state
    // type: optional (string or null) if null or omitted defaults for blend_state are used.
    blend_state: null
    // specify a named raster_state
    // type: optional (string or null) if null or omitted defaults for raster_state are used.
    raster_state: null
    /// specify the name of cbuffers inside .hlsl shader code which should be used as push constants in the pipeline
    /// type: array [string]
    push_constants: []
    /// key-value object of `static_samplers`
    static_samplers: null
    /// specify the mesh topology to use for this pipeline
    /// type: enum [Undefined, PointList, LineList, LineStrip, TriangleList, TriangleStrip, LineListAdj, LineStripAdj, TriangleListAdj, TriangleStripAdj, PatchList]
    topology: TriangleList
}

/// vertex layout, the following settings are applied to all members of a vertex input struct
/// a vertex layout will be generated automatically for all inputs, use this to control instance and step rate
vertex_layout: {
    /// slot to bind the buffer on
    /// type: in
    input_slot: 2
    /// specifies the type of input 
    /// type: enum [PerVertex, PerInstance]
    input_slot_class: PerVertex
    /// the rate at which to step elements in this vertex buffer
    /// type: int
    step_rate: 0
}

/// specify named sampler states to use as static samplers on this pipeline
static_samplers: {
    /// sampler name (in hlsl): sampler state name in pmfx
    sampler0: wrap_linear
}

/// depth stencil state.
depth_stencil_state: {
    /// specifies whether to enable depth testing. set this to `true` to enable depth testing.
    /// type: bool
    depth_enabled: false
    /// identifies a portion of the depth-stencil buffer that can be modified by depth data.
    /// possible values: [Zero, All]
    depth_write_mask: Zero
    /// identifies a function that compares depth data against existing depth data.
    /// type: enum [Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, Always]
    depth_func: Always
    /// specifies whether to enable stencil testing. set this to `true` to enable stencil testing.
    /// type: bool
    stencil_enabled: false
    /// identify a portion of the depth-stencil buffer for reading stencil data.
    /// type: u8 int [0-255]
    stencil_read_mask: 0
    /// identify a portion of the depth-stencil buffer for writing stencil data.
    /// type: u8 int [0-255]
    stencil_write_mask: 0
    /// structure that describes how to use the results of the depth test and the stencil test for pixels 
    /// whose surface normal is facing towards the camera.
    front_face: {
        /// value that identifies the stencil operation to perform when stencil testing fails.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        fail: Keep
        /// value that identifies the stencil operation to perform when stencil testing passes and depth testing fails.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        depth_fail: Keep
        /// typed value that identifies the stencil operation to perform when stencil testing and depth testing both pass.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        pass: Keep
        /// typed value that identifies the function that compares stencil data against existing stencil data.
        /// type: enum [Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, Always]
        func: Always
    }
    /// structure that describes how to use the results of the depth test and the stencil test for pixels 
    /// whose surface normal is facing away from the camera.
    back_face: {
        /// value that identifies the stencil operation to perform when stencil testing fails.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        fail: Keep
        /// value that identifies the stencil operation to perform when stencil testing passes and depth testing fails.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        depth_fail: Keep
        /// typed value that identifies the stencil operation to perform when stencil testing and depth testing both pass.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        pass: Keep
        /// typed value that identifies the function that compares stencil data against existing stencil data.
        /// type: enum [Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, Always]
        func: Always
    }
}

/// sampler state
sampler_states: {
    /// value that specifies the filtering method to use when sampling a texture.
    /// type: enum [Point, Linear, Anisotropic]
    filter: Linear
    /// value that specifies the method to use for resolving a u texture coordinate that is outside the 0 to 1 range.
    /// type: enum [Wrap, Mirror, Clamp, Border, MirrorOnce]
    address_u: Wrap
    /// value that specifies the method to use for resolving a v texture coordinate that is outside the 0 to 1 range.
    /// type: enum [Wrap, Mirror, Clamp, Border, MirrorOnce]
    address_v: Wrap
    /// value that specifies the method to use for resolving a w texture coordinate that is outside the 0 to 1 range.
    /// /// type: enum [Wrap, Mirror, Clamp, Border, MirrorOnce]
    address_w: Wrap
    /// value that specifies a function that compares sampled data against existing sampled data.
    /// type: enum [Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, Always]
    comparison: None
    /// RGBA border color to use if `Border` is specified for address_u, address_v, or address_w.
    /// type: optional u32 int [None, 0x0000 - 0xFFFFFF]
    border_colour: None
    /// offset from the calculated mipmap level.
    /// type: float 
    mip_lod_bias: 0.0
    /// lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level 
    /// and any level higher than that is less detailed.
    /// type: int [1 - 16]
    max_aniso: 1
    /// lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level 
    /// and any level higher than that is less detailed.
    /// type: float
    min_lod: -1.0
    /// upper end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level 
    /// and any level higher than that is less detailed.
    /// type: float
    max_lod: -1.0
}

/// specify blend state for a single render target
render_target_blend_state: {
    /// specifies whether to enable blending. set this to `true` to enable blending.
    /// type: bool
    blend_enabled: false,
    /// specifies whether to enable a logical operation. set to `true` to enable a logical operation. 
    /// **note you cannot enable both blend_enabled and logic_op_enabled
    /// type: bool
    logic_op_enabled: false,
    /// value that specifies the operation to perform on the rgb value that the pixel shader outputs. 
    /// the `blend_op` member defines how to combine the `src_blend` and `dst_blend` operations.
    /// type: enum [Zero, One, SrcColour, InvSrcColour, SrcAlpha, InvSrcAlpha, DstAlpha, InvDstAlpha, DstColour, InvDstColour, SrcAlphaSat, BlendFactor, InvBlendFactor, Src1Colour, InvSrc1Colour, Src1Alpha, InvSrc1Alpha]
    src_blend: Zero,
    /// value that specifies the operation to perform on the rgb value that the pixel shader outputs. 
    /// the `blend_op` member defines how to combine the `src_blend` and `dst_blend` operations.
    /// type: enum [Zero, One, SrcColour, InvSrcColour, SrcAlpha, InvSrcAlpha, DstAlpha, InvDstAlpha, DstColour, InvDstColour, SrcAlphaSat, BlendFactor, InvBlendFactor, Src1Colour, InvSrc1Colour, Src1Alpha, InvSrc1Alpha]
    dst_blend: Zero,
    /// value that defines how to combine the `src_blend` and `dst_blend` operations.
    /// type: enum [Add, Subtract, RevSubtract, Min, Max]
    blend_op: Add,
    /// value that specifies the operation to perform on the alpha value that the pixel shader outputs. 
    /// the `blend_op_alpha` member defines how to combine the `src_blend_alpha` and `dst_blend_alpha` operations.
    /// type: enum [Zero, One, SrcAlpha, InvSrcAlpha, DstAlpha, InvDstAlpha, SrcAlphaSat, BlendFactor, InvBlendFactor, Src1Alpha, InvSrc1Alpha]
    src_blend_alpha: Zero,
    /// value that specifies the operation to perform on the alpha value that the pixel shader outputs. 
    /// the `blend_op_alpha` member defines how to combine the `src_blend_alpha` and `dst_blend_alpha` operations.
    /// type: enum [Zero, One, SrcAlpha, InvSrcAlpha, DstAlpha, InvDstAlpha, SrcAlphaSat, BlendFactor, InvBlendFactor, Src1Alpha, InvSrc1Alpha]
    dst_blend_alpha: Zero,
    /// value that defines how to combine the `src_blend_alpha` and `dst_blend_alpha` operations.
    /// type: enum [Add, Subtract, RevSubtract, Min, Max]
    blend_op_alpha: Add,
    /// value that specifies the logical operation to configure for the render target.
    /// type: enum [Clear, Set, Copy, CopyInverted, NoOp, Invert, And, Nand, Or, Nor, Xor, Equiv, AndReverse, AndInverted, OrReverse, OrInverted]
    logic_op: Clear,
    /// value controls which channels of the render target to write. the chars RGBA are converted to a 4-bit integer mask.
    /// type: enum [R, G, B, A, None, All]
    write_mask: RGBA
}

/// specify blend state for a multiple render targets
blend_state: {
    /// specify whether to enable alpha to coverage or not, set to `true` to enable.
    /// type: bool
    alpha_to_coverage_enabled: false
    /// specify whether to enable independent blending set to `true` to enable. 
    /// if this is true it enables `src_blend_alpha`, `dst_blend_alpha` and `blend_op_alpha` on the `render_target_blend_state`
    /// type: bool
    independent_blend_enabled: false
    /// an array of `render_target_blend_state` to supply different blending controls for multiple render target configurations.
    render_target: []
}

/// specify rasterizer state
raster_states: {
    /// value that specifies the fill mode to use when rendering.
    /// type: enum [Wireframe, Solid]
    fill_mode: Solid
    /// value that specifies that triangles facing the specified direction are not drawn.
    /// type: enum [None, Front, Back]
    cull_mode: None
    /// determines if a triangle is front- or back-facing. If this member is `true`, 
    /// a triangle will be considered front-facing if its vertices are counter-clockwise 
    /// on the render target and considered back-facing if they are clockwise.
    /// type: bool
    front_ccw: false
    /// depth value added to a given pixel.
    /// type: int
    depth_bias: 0
    /// maximum depth bias of a pixel.
    /// type: float
    depth_bias_clamp: 0.0
    /// scalar on a given pixel's slope.
    /// type: float
    slope_scaled_depth_bias: 0.0
    /// specifies whether to enable clipping based on distance.
    /// type: bool
    depth_clip_enable: false
    /// specifies whether to use the quadrilateral or alpha line anti-aliasing algorithm on multisample antialiasing (MSAA) render targets.
    /// type: bool
    multisample_enable: false
    /// specifies whether to enable line antialiasing; only applies if doing line drawing and `multisample_enable` is false. 
    /// type: bool
    antialiased_line_enable: false
    /// the sample count that is forced while UAV rendering or rasterizing. 
    /// 0 indicates that the sample count is not forced.
    /// type: int [0, 1, 4, 8, 16]
    forced_sample_count: 0
    /// value that identifies whether conservative rasterization is on or off.
    /// type: bool
    conservative_raster_mode: false
}

/// specify a texture or render target
texture: {

}

/// specify a view (a render pass into a render target)
view: {

}

/// specify a render graph (collection of views with dependencies)
render_graph: {

}