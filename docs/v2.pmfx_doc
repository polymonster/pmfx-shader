/// this is the full schema for pmfx pipeline specification
/// members are listed with their default values, possible values for enums and types listed in the comments.

/// depth stencil state.
depth_stencil_state: {
    /// specifies whether to enable depth testing. set this to `true` to enable depth testing.
    /// type: bool
    depth_enabled: false
    /// identifies a portion of the depth-stencil buffer that can be modified by depth data.
    /// possible values: [Zero, All]
    depth_write_mask: Zero
    /// identifies a function that compares depth data against existing depth data.
    /// type: enum [Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, Always]
    depth_func: Always
    /// specifies whether to enable stencil testing. set this to `true` to enable stencil testing.
    /// type: bool
    stencil_enabled: false
    /// identify a portion of the depth-stencil buffer for reading stencil data.
    /// type: u8 integer [0-255]
    stencil_read_mask: 0
    /// identify a portion of the depth-stencil buffer for writing stencil data.
    /// type: u8 integer [0-255]
    stencil_write_mask: 0
    /// structure that describes how to use the results of the depth test and the stencil test for pixels whose surface normal is facing towards the camera.
    front_face: {
        /// value that identifies the stencil operation to perform when stencil testing fails.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        fail: Keep
        /// value that identifies the stencil operation to perform when stencil testing passes and depth testing fails.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        depth_fail: Keep
        /// typed value that identifies the stencil operation to perform when stencil testing and depth testing both pass.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        pass: Keep
        /// typed value that identifies the function that compares stencil data against existing stencil data.
        /// type: enum [Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, Always]
        func: Always
    }
    /// structure that describes how to use the results of the depth test and the stencil test for pixels whose surface normal is facing away from the camera.
    back_face: {
        /// value that identifies the stencil operation to perform when stencil testing fails.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        fail: Keep
        /// value that identifies the stencil operation to perform when stencil testing passes and depth testing fails.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        depth_fail: Keep
        /// typed value that identifies the stencil operation to perform when stencil testing and depth testing both pass.
        /// type: enum [Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr]
        pass: Keep
        /// typed value that identifies the function that compares stencil data against existing stencil data.
        /// type: enum [Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, Always]
        func: Always
    }
}

/// sampler state
sampler_states: {
    /// value that specifies the filtering method to use when sampling a texture.
    /// type: enum [Point, Linear, Anisotropic]
    filter: Linear
    /// value that specifies the method to use for resolving a u texture coordinate that is outside the 0 to 1 range.
    /// type: enum [Wrap, Mirror, Clamp, Border, MirrorOnce]
    address_u: Wrap
    /// value that specifies the method to use for resolving a v texture coordinate that is outside the 0 to 1 range.
    /// type: enum [Wrap, Mirror, Clamp, Border, MirrorOnce]
    address_v: Wrap
    /// value that specifies the method to use for resolving a w texture coordinate that is outside the 0 to 1 range.
    /// /// type: enum [Wrap, Mirror, Clamp, Border, MirrorOnce]
    address_w: Wrap
    /// value that specifies a function that compares sampled data against existing sampled data.
    /// type: enum [Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, Always]
    comparison: None
    /// RGBA border color to use if `Border` is specified for address_u, address_v, or address_w.
    /// type: optional u32 integer [None, 0x0000 - 0xFFFFFF]
    border_colour: None
    /// offset from the calculated mipmap level.
    /// type: float 
    mip_lod_bias: 0.0
    /// lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed.
    /// type: integer [1 - 16]
    max_aniso: 1
    /// lower end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed.
    /// type: float
    min_lod: -1.0
    /// upper end of the mipmap range to clamp access to, where 0 is the largest and most detailed mipmap level and any level higher than that is less detailed.
    /// type: float
    max_lod: -1.0
}